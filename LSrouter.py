####################################################
# LSrouter.py
# Name:
# HUID:
#####################################################

from router import Router
from packet import Packet
import json
import heapq
class LSrouter(Router):
    """Link state routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the Router base class for docstrings of the methods to
    override.
    """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0 # theo dõi thời gian gửi LSA gần nhất 
        # TODO
        self.seq = 0 # Số thứ tự của LSA tăng khi LSA được tạo mới 
        self.neighbors = {} # danh sách các node lân cận gồm port nei và cost, dùng để lưu hàng xóm của các router theo cổng
        self.ports_to_neighbors = {} # biết cần gửi ls cho node từ cổng nào, cái này như ánh xạ ngược để biết gửi đến router bày phải qua cổng nào 
        self.lsdb = {} # topology của mạng như là graph để dùng cho ftb
        self.forwarding_table = {} # xây dựng bảng định tuyến
        #   add your own class fields and initialization code here
        # pass

    def handle_packet(self, port, packet): # Mục đích để xử lí 2 loại gói tin : loại dữ liệu (Traceroute) và định tuyến (LSA)
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute: # Với loại tin dữ liệu
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            dst = packet.dst_addr # Lấy địa chỉ của gói tin 
            if dst in self.forwarding_table: # Nếu địa chỉ xuất hiện trong bảng định tuyến 
                out_port = self.forwarding_table[dst] # lấy cổng ra của địa chỉ gói tin 
                self.send(out_port, packet) # Gửi gói tin qua cổng ra vừa trích xuất được
        else:
            # Hint: this is a routing packet generated by your routing protocol
            # If the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors
            lsa = json.loads(packet.content) # Lấy lsa
            name = lsa["name"]
            seq = lsa["seq"]
            links = lsa["links"]
            if name not in self.lsdb or seq > self.lsdb[name]["seq"]: # Nếu tên của gói tin chưa có trong lsdb hoặc số thứ tự mới lớn hơn cái cũ thì được cập nhật lại
                self.lsdb[name] = {
                    "seq": seq,
                    "links": links
                }
                self.run_dijkstra() # Cập nhật lại bảng định tuyến 
                
                for neighbor, p in self.ports_to_neighbors.items(): # gửi lsa đến tất cả hàng xóm, trừ cổng nhận đc gói tin 
                    if p != port:
                        self.send(p, packet)
            

    def handle_new_link(self, port, endpoint, cost): # Cập nhật khi router cập nhật hàng xóm mới 
        """Handle new link."""
        # TODO
        self.neighbors[port] = (endpoint, cost) # port -> (neighbor, cost) . Thêm hàng xóm 
        self.ports_to_neighbors[endpoint] = port # neighbor -> port. Cập nhật ánh xạ ngược 
        self.lsdb[self.addr] = {                 # Cập nhật lại LSDB
            "seq": self.seq,
            "links": {n: c for _, (n, c) in self.neighbors.items()}
        }
        self.seq += 1 # tăng seq để gửi đi
        self.flood_own_lsa() # gửi lsa cho các node lân cận và bản thân
        self.run_dijkstra() # Mục đích cập nhật forwarding Table 
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        
    def handle_remove_link(self, port):
        """Handle removed link."""
        # Xóa liên kết khỏi neighbors và ports_to_neighbors
        if port in self.neighbors:
            endpoint, _ = self.neighbors[port]
            del self.neighbors[port]
            if endpoint in self.ports_to_neighbors:
                del self.ports_to_neighbors[endpoint]
        
        # Cập nhật LSDB của router này
        self.lsdb[self.addr] = {
            "seq": self.seq,
            "links": {n: c for _, (n, c) in self.neighbors.items()}
        }
        self.seq += 1  # Tăng sequence number để đánh dấu LSA mới
        
        # Gửi LSA mới đến các neighbor
        self.flood_own_lsa()
        
        # Tính lại bảng định tuyến
        self.run_dijkstra()

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # Gửi lại LSA của router này đến các neighbor
            self.flood_own_lsa()

    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        # TODO
        #   NOTE This method is for your own convenience and will not be graded
        return f"LSrouter(addr={self.addr})"
    
    def flood_own_lsa(self):
        lsa = {
            "name": self.addr,
            "seq": self.seq,
            "links": {n: c for _, (n, c) in self.neighbors.items()}
        }
        packet = Packet(Packet.ROUTING, self.addr, None, json.dumps(lsa))
        for neighbor, port in self.ports_to_neighbors.items():
            self.send(port, packet)
        

    def run_dijkstra(self):
        graph = {}  # tên router → các hàng xóm và cost
        for router, entry in self.lsdb.items():
            graph[router] = entry["links"]

        dist = {self.addr: 0}
        prev = {}
        visited = set()
        heap = [(0, self.addr)]

        while heap:
            cost_u, u = heapq.heappop(heap)
            if u in visited:
                continue
            visited.add(u)

            for v, cost_uv in graph.get(u, {}).items():
                if v not in dist or cost_u + cost_uv < dist[v]:
                    dist[v] = cost_u + cost_uv
                    prev[v] = u
                    heapq.heappush(heap, (dist[v], v))

        self.forwarding_table = {}

        for dest in dist:
            if dest == self.addr:
                continue
            # truy ngược đường đi để tìm next hop
            next_hop = dest
            while prev.get(next_hop) != self.addr:
                next_hop = prev.get(next_hop, next_hop)
            # ánh xạ next_hop → port
            if next_hop in self.ports_to_neighbors:
                port = self.ports_to_neighbors[next_hop]
                self.forwarding_table[dest] = port